function [currPM currCM Pfg Pbg] = ParseImageUsingLP(imProc, imFG, CM, im, det_bb, limb_mask, class_id, params, verbose)
% parse image im using a updated parsing algorithm aided by body part location priors 
%
% returns posterior map pm and color model cm
%
% if color model cm given, skip initial step of obtaining color models from limb location priors
% 
% if params.img_lik_only
% -> don't do full parsing, stop at extracting the
%    image likelihood and return it inside pm;
%    only works when cm given
%

  % process arguments
  if nargin < 8
    verbose = false;
  end

  if isstruct(imProc)
    motion = imProc.motion;
    imProc = imProc.im;
  else
    motion = [];
  end

  org_height = det_bb(4);

  imsize = size(im);
  imProcSize = size(imProc);
  classname = class_id2name(class_id);

  iterModel = load_iterModel(classname,params);


  % iterModel.www is the weight for the edge filter when used in combo with the color filter
   iterModel.www = ones(size(iterModel.len)); 

  nClasses = size(iterModel.colmask,1);
  nLimbs = size(iterModel.colmask,2);
  nOrients = size(iterModel.orient,2);
  
  if isfield(params,'cues_weight')
    iterModel.cues_weight = params.cues_weight;
  else
    iterModel.cues_weight.edge = ones(1,nLimbs);
    iterModel.cues_weight.color = ones(1,nLimbs);
    iterModel.cues_weight.motion_contrast = ones(1,nLimbs);
    iterModel.cues_weight.motion_consist = ones(1,nLimbs);
  end
  
  [bbt, bbtc] = process_bb(det_bb,imsize([2 1]),class_id,params); 

  if isfield(params,'hidden');
    iterModel.hidden = params.hidden;
  end

   
if verbose
disp('computing edge map');
end

    [m, trash] = mydetGMc(imProc,2); 
    if isfield(params,'edge_magnitude_use') && params.edge_magnitude_use == true
      binary = double(imdilate(m > iterModel.edgeThresh, ones(3)));
      m = imdilate(m,ones(3));
      switch params.edge_magnitude_norm
        case 'binarymean'
          m = m/mean(m(:))*mean(binary(:));      
        case 'Linf'
          m = m/max(m(:));
        otherwise
          error('edge_magnitude_norm - wrong parameter value')
      end
    else
      m = double(imdilate(m > iterModel.edgeThresh, ones(3))); 
    end
  
  
%%Second part corresponding to ParseImage----------------------

if verbose > 1
figh2 = figure;
imshow(im)
DrawBB(wh2mxmxmymy(det_bb), [0 1  0]);
goodaxis, axis off;
figh = figure; 
imshow(imProc);
goodaxis, axis off;
title('image');
drawnow;
end

  % prepare edge map

  % ? better edge detector (using magnitude instead of thesholding or even incorporating orientations)

  if params.use_fg_high
    
     imFG = imdilate(imFG,ones(9));                  % dilate to make sure all edges are in fg
      m(~imFG) = 0;                                 % remove non-fg pixels from the edgemap m

    if verbose
      disp('keep only cues values on foreground highlit area');
    end
  end
  
if verbose > 1
figure(figh); subplot(2,2,2);
imshow(m);
goodaxis; axis off;
title('edges');
drawnow;
end



  % limb location constraints
  if not(islogical(limb_mask))
    % dilate and intersect with fg
    for lix = 1:length(limb_mask)
      if not(isempty(limb_mask{lix}))
        %moutl{lix} = imdilate(mask{lix},ones(9));  % CVPR08 figures
        %moutl{lix} = bwoutlines(moutl{lix}, 4); 
        %moutl{lix} = imdilate(moutl{lix},ones(3));      % add some thickness
        limb_mask{lix} = imdilate(limb_mask{lix},ones(9));
      end
    end
    %
if verbose > 1
imMask = HighlightImageMultiAreas(imProc, limb_mask, classname);
%imMask = SuperimposeImageMultiAreas(im, moutl, classname); % CVPR08 figs; 1 -> not transparent
figure(figh); subplot(2,2,1);
imagesc(imMask);
goodaxis; axis off;
drawnow;
end % verbose

  end % given limb masks ?
  


  % color model not given ?
  if islogical(CM)
    % parse1 phase
    % Do first parse
    % get first posterior map for each limb
if verbose
disp('-> computing first parse using edges and color models obtained from the location priors');
end
    [Pfg Pbg temp_imgCrop] = calcCMwrapper(im,bbt,bbtc,[],params.lp_params{class_id},params.cm_params,'fgbg',0);
    fgP = applyCMTransfer(Pfg,Pbg,params.lp_params{class_id}.transfer_weights);
  else  
    % color model given
if verbose
disp('color model given -> skipping parse with color model generated by the location priors');
end
    CM = unfoldCM(CM,params.cm_params);
    fgP = CM.cm;
    bbtcMM = wh2minmax(bbtc);
    temp_imgCrop = im(bbtcMM(2):bbtcMM(4),bbtcMM(1):bbtcMM(3),:);
    switch params.cm_params.colorSpace
      case 'lab'
        temp_imgCrop = labImgScale255(rgb2lab_vitto(temp_imgCrop));
      case 'rgb'
        temp_imgCrop = double(temp_imgCrop);
    end
  end

  % prepare motion auxiliary images if necesary
  
    motion = [];

  


  %----------------
  % do parsing at least one time
  if isfield(params,'lp_use_additional_stages')
    if length(params.lp_use_additional_stages) == 1
      params.lp_use_additional_stages(class_id) = params.lp_use_additional_stages;
    end
    iter = params.lp_use_additional_stages(class_id)+1;
  else 
    iter = 1;
  end
  
  while iter
    
if verbose
tic
end
    iter = iter - 1;
    % select colors which are more likely to be foreground than background for a limb group
    if params.lp_threshold_fgP
      fgP = double(fgP > .5);
    end
    seg = calcSegMaskFromPosterior(temp_imgCrop,fgP,params.cm_params.quantiz,0);
    seg = imresize(seg, imProcSize([1 2]), 'bilinear');
    if ~params.lp_use_smooth_seg
      if isfield(params,'segm_thresh')
        seg = seg > params.segm_thresh;
      else
        seg = seg > .5;
      end
    end
    if params.use_fg_high
      seg = MaskImage(seg, imFG);                     % remove non-fg pixels from the actual segmentation
    end
    [res samples] = expected_genmodel_FHedgecolsW_LP( seg, m, limb_mask, iterModel, params.img_lik_only, params.part_ids{class_id}, params.orient_ids{class_id}, params.relor_inhibit,motion,iter==0);
    if params.img_lik_only && iter == 0
if verbose
disp('-> only compute image likelihood in the last iter');
end
      currPM = res;
      currCM.cm = [];
      currCM.Pfg = [];
      currCM.Pbg = [];
      return;
    end
    % update color models using part/class specyfic location posterior
    partMap = buildLimbMap(res,iterModel,params.lp_params{class_id});
    partMap = imresize(partMap, [bbtc(4) bbtc(3)], 'bilinear');
    [Pfg Pbg temp_imgCrop] = calcCMwrapper(im,bbt,bbtc,partMap,params.lp_params{class_id},params.cm_params,'fgbg',0);
    fgP = applyCMTransfer(Pfg,Pbg,params.lp_params{class_id}.transfer_weights);




if verbose
toc
if verbose > 1 && iter == params.lp_use_additional_stages(class_id)
figure(figh); subplot(2,2,3); imagesc(uint8(res.a*2e3));
axis equal; axis tight; axis off;
title('first parse on edges and location prior CM with Transfer');
if isfield(res,'MAP') && ~isempty(res.MAP)
  subplot(2,2,3);
  DrawStickman(res.MAP.sticks);
end
drawnow;
end
end

  end %while iter
  %------------------

%display results
if verbose
disp([ '-> ' num2str(params.lp_use_additional_stages(class_id)) ' additional parse(s) computed using edges and color models obtained from previous iteration']);
if verbose > 1 && params.lp_use_additional_stages(class_id)
figure(figh); subplot(2,2,4); imagesc(uint8(res.a*2e3));
axis equal; axis tight; axis off;
title([ num2str(params.lp_use_additional_stages(class_id)) ' additional parse(s) on edges and posterior part location CM with Transfer']);
if isfield(res,'MAP') && ~isempty(res.MAP)
  subplot(2,2,1);
  DrawStickman(res.MAP.sticks);
end
end
if verbose > 1
drawnow;
keyboard;
end
end


if verbose
disp(['total pose entropy ' num2str(res.e)]);
disp(['total pixel confidence ' num2str(res.p)]);
end

  % assign outputs
  currPM = res;
  currCM.cm = fgP;
  currCM.Pfg = Pfg;
  currCM.Pbg = Pbg;
  currCM = foldCM(currCM,params.cm_params);
end
